#!/usr/bin/perl -wT

use strict;
use List::Util qw[min max];

# Ideal values for a system
# CPU cores
my $ideal_cpu = 2;
# MB of memory
my $ideal_mem = 480;
# GB of disk
my $ideal_disk = 6.7;

# Untaint $ENV{PATH}
$ENV{PATH}="/bin:/usr/bin";

# Grab the short hostname
my $hostname = `hostname -f`;
$hostname =~ s/\.?$//;  # nuke the trailing "." on the end of the fqdn (if it's there)
$hostname =~ m/([a-z0-9\-\.]*)/; # untaint
$hostname = $1;

# Nagios return codes
# Status codes: 0=OK, 1=Warning, 2=Critical, 3=Unknown
my %returncode;
$returncode{'0'} = 'OK';
$returncode{'1'} = 'WARNING';
$returncode{'2'} = 'CRITICAL';
$returncode{'3'} = 'UNKNOWN';

my $cpu_cores = `cat /proc/cpuinfo | grep "model name" | wc -l`;
$cpu_cores =~ m/([0-9]*)/; # untaint
$cpu_cores = $1;

my $mem = `cat /proc/meminfo | grep MemTotal`;
$mem =~ m/.([0-9]+)./; # untaint
$mem = int($1/1024);

my $disk = `df -h / | tail -n 1`;
$disk =~ m/\/dev[^ ]* +([0-9\.]*)/; # Grab the first numerical column after the device path
$disk = $1;

my $cpu_status;
my $cpu_text;
if ($cpu_cores >= $ideal_cpu) {
	$cpu_status = 0;
	$cpu_text = "$cpu_cores cores.";
} else {
	$cpu_status = 1;
	$cpu_text = "$cpu_cores cores. Recommend at least $ideal_cpu cores.";
}

my $mem_status;
my $mem_text;
if ($mem >= $ideal_mem) {
	$mem_status = 0;
	$mem_text = "$mem MB of memory.";
} else {
	$mem_status = 1;
	$mem_text = "$mem MB of memory. Recommend at least $ideal_mem MB.";
}

my $disk_status;
my $disk_text;
if ($disk >= $ideal_disk) {
	$disk_status = 0;
	$disk_text = "$disk GB of disk.";
} else {
	$disk_status = 1;
	$disk_text = "$disk GB of disk. Recommend at least $ideal_disk GB.";
}

my $status = max($cpu_status, $mem_status, $disk_status);
my $text = "HARDWARE SPEC $returncode{$status} - $cpu_text $mem_text $disk_text\n";
my $return = `echo "$hostname,Hardware spec,$status,$text" | /usr/sbin/send_nsca -d , -H <%= scope.lookupvar("::monitoring_server") %>`;
